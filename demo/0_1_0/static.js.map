{"version":3,"sources":["webpack://browsered-jasmine-cucumber/webpack/universalModuleDefinition","webpack://browsered-jasmine-cucumber/webpack/bootstrap","webpack://browsered-jasmine-cucumber/./browsered-jasmine-cucumber.js","webpack://browsered-jasmine-cucumber/./browsered-jasmine-cucumber/Runner/AsyncExecuter.js","webpack://browsered-jasmine-cucumber/./browsered-jasmine-cucumber/Runner/FeatureRunner.js","webpack://browsered-jasmine-cucumber/./browsered-jasmine-cucumber/Runner/GroupsRunner.js","webpack://browsered-jasmine-cucumber/./browsered-jasmine-cucumber/Runner/ScenarioExecuter.js","webpack://browsered-jasmine-cucumber/./browsered-jasmine-cucumber/Runner/SpecStepsSearcher.js","webpack://browsered-jasmine-cucumber/./browsered-jasmine-cucumber/Runner/StepExecuter.js","webpack://browsered-jasmine-cucumber/./browsered-jasmine-cucumber/Runner/utils.js","webpack://browsered-jasmine-cucumber/./browsered-jasmine-cucumber/core.js","webpack://browsered-jasmine-cucumber/./browsered-jasmine-cucumber/cucumber.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA,iCAAO;AACP,IAAI,kGAAiC;AACrC,IAAI,0GAAqC;AACzC,IAAI,gIAAgD;AACpD,CAAC,mCAAE;AACH;;AAEA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;ACXF;AACA;AACA;AACA,iCAAO;;AAEP,CAAC,mCAAE;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC/EF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAO;AACP,IAAI,kIAAiD;AACrD,CAAC,mCAAE;AACH;AACA;AACA;AACA;AACA;AACA,aAAa;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC3DF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAO;AACP,IAAI,kIAAiD;AACrD,IAAI,wIAAoD;AACxD,IAAI,kIAAiD;AACrD,IAAI,kHAAyC;AAC7C,CAAC,mCAAE;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb;;;AAGA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC;AAAA,oGAAC;;;;;;;;;;;;AC9HF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAO;AACP,IAAI,kIAAiD;AACrD,IAAI,gIAAgD;AACpD,IAAI,0IAAqD;AACzD,CAAC,mCAAE;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,CAAC;AAAA,oGAAC,C;;;;;;;;;;;ACzEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAO;;AAEP,CAAC,mCAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;;;AAGjB;AACA;AACA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,eAAe;AACtC;AACA;AACA,iBAAiB;AACjB;AACA;AACA,uDAAuD;AACvD;AACA;AACA;;AAEA;AACA;AACA,CAAC;AAAA,oGAAC,C;;;;;;;;;;;ACzKF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAO;;AAEP,CAAC,mCAAE;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAAA,oGAAC,C;;;;;;;;;;;ACpDF;AACA;AACA;AACA,mBAAO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,C;;;;;;;;;;;ACTF;AACA;AACA;AACA,mBAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,C;;;;;;;;;;;ACVF;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qGAAqG,WAAW;AAChH;AACA;AACA;AACA;AACA;AACA,qGAAqG,YAAY;AACjH;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC,2D","file":"static.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"browsered-jasmine-cucumber\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"browsered-jasmine-cucumber\"] = factory();\n\telse\n\t\troot[\"browsered-jasmine-cucumber\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./browsered-jasmine-cucumber.js\");\n","/**\r\n * Created by steb on 18.02.2015.\r\n */\r\ndefine([\r\n    'browsered-jasmine-cucumber/core',\r\n    'browsered-jasmine-cucumber/cucumber',\r\n    'browsered-jasmine-cucumber/Runner/GroupsRunner'\r\n], function(bjc, c, GroupsRunner){\r\n    window.GroupsRunner = bjc.GroupsRunner = GroupsRunner;\r\n\r\n    return bjc;\r\n});\r\n","/**\r\n * Created by steb on 17.02.2015.\r\n */\r\ndefine([\r\n\r\n], function () {\r\n    function AsyncExecuter(steps, scenarioContext) {\r\n        // запускает шаги один за другим\r\n        // если один из шагов запрашивает асинхронное выполнение (продолжение по коллбэку)\r\n        // запуск цепочки прерываеться на запросившем\r\n        // и продолжаеться по коллбэку - который говорит, что асинхронная опирация завершилась\r\n        var\r\n            currentStep = -1,\r\n            isAsync = false,\r\n            executingStep = false,\r\n            context = {\r\n                async: function () {\r\n                    isAsync = true;\r\n                    return function () {\r\n                        // хитрая валидация на кривые руки клиента: если step в себе сохранил\r\n                        // контекст и в отдельном потоке постарался вызвать async\r\n                        // и после завершить, в то время, как остальной код выполнялся.\r\n                        // правда она не обязательно спасает от неправильного doneCallback\r\n                        if (executingStep) {\r\n                            isAsync = false;\r\n                        }\r\n                        else {\r\n                            executeNextStep();\r\n                        }\r\n                    };\r\n                }\r\n            },\r\n            doneCallback;\r\n\r\n        function executeNextStep() {\r\n            isAsync = false;\r\n\r\n            // if there is a next step\r\n            if (currentStep + 1 < steps.length) {\r\n                currentStep++;\r\n\r\n                executingStep = true;\r\n                steps[currentStep].call(scenarioContext, context);\r\n                executingStep = false;\r\n\r\n                if (!isAsync) {\r\n                    executeNextStep();\r\n                }\r\n            }\r\n            else {\r\n                doneCallback();\r\n            }\r\n        };\r\n\r\n        return function run(done) {\r\n            doneCallback = done;\r\n            executeNextStep();\r\n        };\r\n    };\r\n\r\n\r\n    AsyncExecuter.makeFramingActions = function (position, relevantSteps) {\r\n        return function (featureContext) {\r\n            var framingSteps = relevantSteps.reduce(function (reduce, item) {\r\n                return reduce.concat(item[position]);\r\n            }, []);\r\n\r\n            return framingSteps.length > 0\r\n                ? AsyncExecuter(framingSteps, featureContext)\r\n                : nop;\r\n        };\r\n    };\r\n\r\n\r\n    return AsyncExecuter;\r\n\r\n\r\n    function nop() {\r\n    }\r\n});\r\n","/**\r\n * Created by steb on 17.02.2015.\r\n *\r\n * задача:\r\n * .получить методы обрамления фичи\r\n * .получить набор сценариев для запуска\r\n *\r\n * получает:\r\n * .featureSpec - спецификацию текущей фичи.\r\n * .featuresDescriptions - описание всех фич.\r\n *\r\n * время жизни - выполнение текущей фичи.\r\n */\r\ndefine([\r\n    'browsered-jasmine-cucumber/Runner/AsyncExecuter'\r\n], function (AsyncExecuter) {\r\n    return function FeatureRunner(featureSpec, featuresDescriptions) {\r\n        var\r\n            featureRunner = this,\r\n            relevantFeatureSteps = featuresDescriptions.filter(function (item) {\r\n                return item.pattern.test(featureSpec.description);\r\n            });\r\n\r\n\r\n        featureRunner.getFramingActions = function () {\r\n            return {\r\n                before: AsyncExecuter.makeFramingActions(\r\n                    'beforeSteps',\r\n                    relevantFeatureSteps\r\n                ),\r\n                after: AsyncExecuter.makeFramingActions(\r\n                    'afterSteps',\r\n                    relevantFeatureSteps\r\n                )\r\n            };\r\n        };\r\n\r\n        featureRunner.getSteps = function(){\r\n            return relevantFeatureSteps;\r\n        };\r\n\r\n        featureRunner.getActiveScenarios = function () {\r\n            // фильтруем сценарии not|only\r\n            var scenarios = featureSpec.scenarios.filter(function (item) {\r\n                return item.isOnly;\r\n            });\r\n\r\n            // if we have no scenarios to run specifically (isOnly) then run them all\r\n            if (scenarios.length === 0) {\r\n                // then run them all\r\n                scenarios = featureSpec.scenarios.filter(function (item) {\r\n                    return !item.never;\r\n                });\r\n            }\r\n            return scenarios;\r\n        };\r\n\r\n        return this;\r\n    };\r\n});\r\n","/**\r\n * получает:\r\n * .featureSpecGroups - фичи по группам.\r\n * .stepDescriptionLayers - выполняемые описания по слоям (feature, background, group)\r\n *\r\n * задача:\r\n * .для данной группы выполнить все фичи в ней\r\n */\r\ndefine([\r\n    'browsered-jasmine-cucumber/Runner/FeatureRunner',\r\n    'browsered-jasmine-cucumber/Runner/ScenarioExecuter',\r\n    'browsered-jasmine-cucumber/Runner/AsyncExecuter',\r\n    'browsered-jasmine-cucumber/Runner/utils'\r\n], function (FeatureRunner, ScenarioExecuter, AsyncExecuter, utils) {\r\n    return function GroupAdapter(featureSpecGroups, stepDescriptionLayers) {\r\n        return function (group) {\r\n            groupRunner(group, featureSpecGroups, stepDescriptionLayers);\r\n        };\r\n    };\r\n\r\n    function groupRunner(group, featureSpecGroups, stepDescriptionLayers) {\r\n        var\r\n            groupFraming, addFeatureSteps;\r\n\r\n        group != 'undefined'\r\n            ? describe(group, groupRunner)\r\n            : groupRunner();\r\n\r\n\r\n        function featureRunner(featureSpec) {\r\n            var\r\n                featureRunner = FeatureRunner(\r\n                    featureSpec, utils.extract(\r\n                        stepDescriptionLayers, 'featureSteps', [])\r\n                ),\r\n                featureFraming = featureRunner.getFramingActions(),\r\n                scenarioExecuter = ScenarioExecuter(\r\n                    utils.extract(stepDescriptionLayers, 'backgroundSteps' , [])\r\n                ),\r\n                addScenarioSteps = addFeatureSteps(featureRunner.getSteps());\r\n\r\n            describe(featureSpec.description, function () {\r\n                featureRunner.getActiveScenarios().forEach(function (scenario) {\r\n                    var\r\n                        scenarioFraming, scenarioContext = {};\r\n\r\n                    scenarioExecuter.setUp(scenario, addScenarioSteps, scenarioContext);\r\n                    scenarioFraming = scenarioExecuter.getFramingActions();\r\n\r\n                    describe(scenario.fullDescription, function () {\r\n                        beforeAll(groupFraming.before(scenarioContext));\r\n                        beforeAll(scenarioFraming.before(scenarioContext));\r\n                        beforeAll(featureFraming.before(scenarioContext));\r\n\r\n                        scenarioExecuter.getSteps(scenarioContext).forEach(function (step) {\r\n\r\n                            it(step.description, step.step);\r\n\r\n                        });\r\n\r\n                        afterAll(featureFraming.after(scenarioContext));\r\n                        afterAll(scenarioFraming.after(scenarioContext));\r\n                        afterAll(groupFraming.after(scenarioContext));\r\n                    });\r\n                });\r\n            });\r\n        }\r\n\r\n\r\n        function groupRunner() {\r\n            var actions = utils.extract(\r\n                stepDescriptionLayers, 'groupSteps', []\r\n            ).filter(function (item) {\r\n                    return item.pattern.test(group);\r\n                });\r\n\r\n            groupFraming = {\r\n                before: AsyncExecuter.makeFramingActions(\r\n                    'beforeSteps', actions\r\n                ),\r\n                after: AsyncExecuter.makeFramingActions(\r\n                    'afterSteps', actions\r\n                )};\r\n\r\n            addFeatureSteps = resolveGroup(actions);\r\n\r\n            featureSpecGroups[group].forEach(featureRunner);\r\n        }\r\n\r\n\r\n        function nop() {\r\n        }\r\n    }\r\n\r\n    function resolveGroup(groupSteps) {\r\n        return function resolveFeature(featureSteps) {\r\n            return function makeLayersArray(backgroundSteps) {\r\n                // нужно сформировать массивы из specSteps в которых производить поиск\r\n                // при этом, нужно отфильтровать\r\n                // steps текущей гуппы, steps текущего фона, steps текущей фичи\r\n                return [\r\n                    {\r\n                        key: undefined,\r\n                        steps: extractSteps(featureSteps)\r\n                    },\r\n                    {\r\n                        key: 'background',\r\n                        steps: extractSteps(backgroundSteps)\r\n                    },\r\n                    {\r\n                        key: 'group',\r\n                        steps: extractSteps(groupSteps)\r\n                    }\r\n                ]\r\n            }\r\n        };\r\n\r\n        function extractSteps(item) {\r\n            if (!item)\r\n                return [];\r\n\r\n            return item.reduce(function (r, i) {\r\n                return r.concat(i.steps);\r\n            }, []);\r\n        }\r\n    }\r\n});\r\n","/**\r\n * Created by steb on 17.02.2015.\r\n *\r\n * получает:\r\n * .спецификацию сценария - scenarioSpec\r\n * ..given/when/then\r\n * ..use(background)\r\n *\r\n * .шаги по слоям - FeatureSteps - для group, feature\r\n * ..after/before\r\n * ..given/when/then('matcher', function(){})\r\n *\r\n * .ссылку на контейнер фонов - FeatureSteps внутри\r\n *\r\n * живёт в течении выполнения фичи, при выполнении следующей - создаю новый\r\n *\r\n * задачи:\r\n * .создать вызовы обрамляющих действий\r\n * ..по имени фона в scenarioSpec, найти в контейнере фонов все фоны и выдернуть у них действия обрамления\r\n * ..обернуть выдернутые действия в AsyncExecuter\r\n *\r\n * .создать для данного scenarioSpec массив с вызовами шагов сценария\r\n * ..найти шаги из уровней\r\n */\r\ndefine([\r\n    'browsered-jasmine-cucumber/Runner/AsyncExecuter',\r\n    'browsered-jasmine-cucumber/Runner/StepExecuter',\r\n    'browsered-jasmine-cucumber/Runner/SpecStepsSearcher'\r\n], function (AsyncExecuter, StepExecuter, SpecStepsSearcher) {\r\n    return function ScenarioExecuter(backgroundStepDescriptions) {\r\n        var\r\n            _scenario, _stepsLayers,\r\n            relevantScenarioSteps;\r\n\r\n        return {\r\n            setUp: function (scenario, stepsBuilder) {\r\n                relevantScenarioSteps = backgroundStepDescriptions\r\n                    .filter(function (item) {\r\n                        return item.pattern.test(scenario.background);\r\n                    }\r\n                );\r\n\r\n                _scenario = scenario, _stepsLayers = stepsBuilder(relevantScenarioSteps);\r\n\r\n                scenario.fullDescription = scenario.description + (scenario.background\r\n                    ? ' (bg:' + scenario.background + ')'\r\n                    : '');\r\n            },\r\n\r\n            getFramingActions: function () {\r\n                return {\r\n                    before: AsyncExecuter.makeFramingActions(\r\n                        'beforeSteps',\r\n                        relevantScenarioSteps\r\n                    ),\r\n                    after: AsyncExecuter.makeFramingActions(\r\n                        'afterSteps',\r\n                        relevantScenarioSteps\r\n                    )\r\n                };\r\n            },\r\n\r\n            getSteps: function (scenarioContext) {\r\n                var search = new SpecStepsSearcher(_scenario, _stepsLayers);\r\n\r\n                return _scenario.steps.map(function (stepSpec) {\r\n                    return new StepExecuter(\r\n                        stepSpec, scenarioContext, search\r\n                    );\r\n                });\r\n            }\r\n        };\r\n    };\r\n});","/**\r\n * Created by steb on 17.02.2015.\r\n *\r\n * фактор:\r\n * .есть несколько уровней: [группы, фона, фичи]\r\n * .есть приоритет сопоставления - в начале фичи, потом фона, потом группы.\r\n * .есть модификаторы приоритета - начинать откуда либо до какого уровня пропускать\r\n *\r\n * задача:\r\n * .поискать в каждой группе (учитывая приоритет и пропуск)\r\n * .если на уровне нашлись несколько - вернуть действие с ошибкой и вопросом какой\r\n * .если ни один не нашёлся - сгенерить массив близких по всем искомым и спросить - какой?\r\n *\r\n * получает:\r\n * .список: имя уровня, stepsDescriptions\r\n * .scenarioSpec\r\n *\r\n * время жизни - один сценарий, т.к. у следующего будет другой список уровней.\r\n */\r\ndefine([\r\n\r\n], function () {\r\n    return function SpecStepsSearcher(scenarioSpec, stepsLevels) {\r\n\r\n        return function getStep(description, scenarioContext) {\r\n            var\r\n                isSearching = false,\r\n                levelNum = -1,\r\n                stepsDefinitions = [];\r\n\r\n            function search() {\r\n                levelNum++;\r\n                if (levelNum >= stepsLevels.length)\r\n                    return function () {\r\n                        throw new Error('Missing step definitions: ' +\r\n                            stepWithLikelyMatch(description.description, stepsDefinitions));\r\n                    };\r\n\r\n                var level = stepsLevels[levelNum];\r\n                isSearching = isSearching || description.level === level.key;\r\n                if (!isSearching)\r\n                    return search();\r\n\r\n                var found = getStepForLayer(description, level.steps, scenarioContext);\r\n                if (found.action) {\r\n                    return found.action;\r\n                }\r\n                if (found.length > 1)\r\n                    return function () {\r\n                        throw new Error('Had few matches: ' + found.steps\r\n                                .map(mapDescription)\r\n                                .join('\\n\\t')\r\n                        )\r\n                    };\r\n\r\n                stepsDefinitions = level.steps.reduce(reduceItem, stepsDefinitions);\r\n                return search();\r\n            }\r\n\r\n            return search();\r\n\r\n            function reduceItem(reduce, item) {\r\n                return reduce.concat(item);\r\n            }\r\n        };\r\n\r\n        function getStepForLayer(description, stepsDefinitions, scenarioContext) {\r\n            // look for 1 and only one match step\r\n            var matchingSteps = stepsDefinitions\r\n                .map(function (item) {\r\n                    var result = item.pattern.exec(description.description);\r\n                    return {\r\n                        definition: item.definition,\r\n                        pattern: item.pattern,\r\n                        arguments: result ? result.slice(1).concat(description.arguments) : [],\r\n                        match: !!result\r\n                    };\r\n                })\r\n                .filter(function (item) {\r\n                    return item.match;\r\n                });\r\n\r\n\r\n            if (matchingSteps.length !== 1)\r\n                return {\r\n                    length: matchingSteps.length,\r\n                    steps: matchingSteps\r\n                };\r\n\r\n            return {action: function () {\r\n                // TODO: ideally we could be detecting failed jasmine matcher so that we can include this description\r\n                //  as the step that failed. But that is proving to be very difficult requiring custom matchers...\r\n                if (description.keyword != 'Then')\r\n                    expect(true).toBeTruthy();\r\n\r\n                matchingSteps[0].definition.apply(scenarioContext, matchingSteps[0].arguments);\r\n            }};\r\n        }\r\n    };\r\n\r\n\r\n    function stepWithLikelyMatch(unknownDescription, stepsDefinitions) {\r\n        console.log(stepsDefinitions);\r\n\r\n        var candidates = stepsDefinitions.reduce(function (memo, step) {\r\n            return memo.concat(step.name);\r\n        }, [])\r\n            .map(function (item) {\r\n                return item;\r\n            })\r\n            .filter(onlyUnique)\r\n            .map(function (knownDescription) {\r\n                return {\r\n                    description: knownDescription,\r\n                    score: levenshteinDistance(unknownDescription, knownDescription)\r\n                };\r\n            })\r\n            .sort(function (l, r) {\r\n                return l.score - r.score;\r\n            })\r\n            .map(function (item) {\r\n                return item.description + ' (' + item.score + ')';\r\n            })\r\n            .slice(0, 5);\r\n        return unknownDescription + '\\n\\t\\tDid you mean?\\n\\t\\t\\t' + candidates.join('\\n\\t\\t\\t');\r\n    }\r\n\r\n    function onlyUnique(value, index, self) {\r\n        return self.indexOf(value) === index;\r\n    }\r\n\r\n    function mapDescription(step) {\r\n        return step.description;\r\n    }\r\n\r\n\r\n    function levenshteinDistance(a, b) {\r\n        if (a.length === 0) return b.length;\r\n        if (b.length === 0) return a.length;\r\n\r\n        var matrix = [];\r\n\r\n        // increment along the first column of each row\r\n        var i;\r\n        for (i = 0; i <= b.length; i++) {\r\n            matrix[i] = [i];\r\n        }\r\n\r\n        // increment each column in the first row\r\n        var j;\r\n        for (j = 0; j <= a.length; j++) {\r\n            matrix[0][j] = j;\r\n        }\r\n\r\n        // Fill in the rest of the matrix\r\n        for (i = 1; i <= b.length; i++) {\r\n            for (j = 1; j <= a.length; j++) {\r\n                if (b.charAt(i - 1) == a.charAt(j - 1)) {\r\n                    matrix[i][j] = matrix[i - 1][j - 1];\r\n                } else {\r\n                    matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution\r\n                        Math.min(matrix[i][j - 1] + 1, // insertion\r\n                                matrix[i - 1][j] + 1)); // deletion\r\n                }\r\n            }\r\n        }\r\n\r\n        return matrix[b.length][a.length];\r\n    }\r\n});","/**\r\n * Created by steb on 17.02.2015.\r\n *\r\n * факторы:\r\n * .вызываеться it-ом jasmin-а\r\n * .во время вызова должен получить step из ScenarioExecuter по stepSpec\r\n * ..stepSpec - описание given/when/then из scenarioSpec - вводим в спецификации\r\n *\r\n * получает:\r\n * .stepSpec\r\n * .scenarioContext - объект передаваемый всем шагам сценария\r\n * .getStep - выдаёт функцию данного шага из *.steps.js - stepDescription по stepSpec\r\n */\r\ndefine([\r\n\r\n], function () {\r\n    return function StepExecuter(stepSpec, scenarioContext, getStep) {\r\n        var\r\n            stepExecutor = this;\r\n\r\n        stepExecutor.description = stepSpec.fullDescription;\r\n\r\n        stepExecutor.step = function (done) {\r\n            // т.е. выполняеться только по запросу it-ом\r\n            var\r\n                step = getStep(stepSpec, scenarioContext),\r\n                asyncContext = getAsyncForStep(done);\r\n\r\n            scenarioContext.async = asyncContext.async;\r\n            step();\r\n            asyncContext.done();\r\n        };\r\n\r\n\r\n        return this;\r\n\r\n\r\n        function getAsyncForStep(done) {\r\n            var called = false;\r\n\r\n            return {\r\n                async: function () {\r\n                    called = true;\r\n                    return done;\r\n                },\r\n                done: function () {\r\n                    if (called) return;\r\n                    done();\r\n                }\r\n            }\r\n        }\r\n    }\r\n});","/**\r\n * Created by steb on 18.02.2015.\r\n */\r\ndefine({\r\n    extract: function (item, field, default_) {\r\n        return (item && item[field])\r\n            ? item[field]\r\n            : default_;\r\n    }\r\n});","/**\r\n * Created by steb on 18.02.2015.\r\n */\r\ndefine({\r\n    info: {\r\n        version: '0.1.0',\r\n        deps: {\r\n            jasmine: '2.0.0'\r\n        }\r\n    }\r\n});","(function (exports) {\r\n    exports.fetureGroups = {};\r\n    exports.fetureGroups[undefined] = []; // что-бы эта группа выполнялась первой\r\n    exports.stepsGroups = {};\r\n\r\n    var featureRunner = {\r\n        enqueue: function (feature, group) {\r\n            var group = exports.fetureGroups[group] || (exports.fetureGroups[group] = []);\r\n            group.push(feature);\r\n        }\r\n    };\r\n\r\n    function Feature(featureDescription, groupName) {\r\n        function Scenario(scenarioDescription, options) {\r\n            function Examples() {\r\n                var self = this;\r\n\r\n                this.add = function (name, params) {\r\n                    return self;\r\n                };\r\n            };\r\n\r\n\r\n            var self = this;\r\n            options = options || {};\r\n            this.description = scenarioDescription;\r\n            this.steps = [];\r\n            this.addStep = function () {\r\n                var args = Array.prototype.splice.call(arguments, 2);\r\n                this.steps.push({\r\n                    description: arguments[1],\r\n                    fullDescription: arguments[0] + '  ' + arguments[1] + ' ' + (args && args.length > 0 ? JSON.stringify(args, null, 2) : ''),\r\n                    arguments: args,\r\n                    keyword: arguments[0]\r\n                });\r\n            };\r\n\r\n            this.given = function () {\r\n                this.addStep.apply(this, ['Given'].concat(Array.prototype.slice.call(arguments, 0)));\r\n\r\n                self.and = function () {\r\n                    this.addStep.apply(this, ['And'].concat(Array.prototype.slice.call(arguments, 0)));\r\n                    return self;\r\n                };\r\n\r\n                return self;\r\n            };\r\n            this.when = function () {\r\n                self.addStep.apply(this, ['When'].concat(Array.prototype.slice.call(arguments, 0)));\r\n\r\n                self.and = function () {\r\n                    self.addStep.apply(this, ['And'].concat(Array.prototype.slice.call(arguments, 0)));\r\n                    return self;\r\n                };\r\n\r\n                return self;\r\n            };\r\n            this.then = function () {\r\n                self.addStep.apply(this, ['Then'].concat(Array.prototype.slice.call(arguments, 0)));\r\n\r\n                self.and = function () {\r\n                    self.addStep.apply(this, ['And'].concat(Array.prototype.slice.call(arguments, 0)));\r\n                    return self;\r\n                };\r\n\r\n                return self;\r\n            };\r\n\r\n            // could add this.and as a default - but at least this way you don't get and until you use given, when or then\r\n            this.isOnly = options.only === true ? true : false;\r\n            this.never = options.not === true ? true : false;\r\n\r\n\r\n            this.fromBackground = makePrioritySetter('background');\r\n            this.fromGroup = makePrioritySetter('group');\r\n            function makePrioritySetter(level) {\r\n                return function () {\r\n                    var step = self.steps[self.steps.length - 1];\r\n                    if (!step)\r\n                        throw new Error(\"Can't modify level without adding a step\");\r\n\r\n                    step.level = level;\r\n                    step.fullDescription += ' (' + level + ')';\r\n                    return self;\r\n                };\r\n            }\r\n\r\n\r\n            exports.examples = function () {\r\n                return new Examples();\r\n            };\r\n        }\r\n\r\n\r\n        var self = this;\r\n\r\n        this.description = featureDescription;\r\n        this.groupName = groupName;\r\n        this.scenarios = [];\r\n        exports.scenario = function (scenarioDescription) {\r\n            var scenario = new Scenario(scenarioDescription);\r\n            self.scenarios.push(scenario);\r\n            return scenario;\r\n        };\r\n\r\n        //факт: сценарии в фиче можно помечать [не запускать, только эту заупскать]\r\n        this.not = {\r\n            scenario: function () {\r\n                return exports.scenario.apply(self, Array.prototype.slice.call(arguments, 0).concat({ not: true}));\r\n            }\r\n        };\r\n        // запускать только данный из всех\r\n        this.only = {\r\n            scenario: function () {\r\n                return exports.scenario.apply(self, Array.prototype.slice.call(arguments, 0).concat({ only: true}));\r\n            }\r\n        };\r\n\r\n\r\n        this.add = this.with = function (example) {\r\n            return self;\r\n        };\r\n\r\n        //факт: фиче можно задать фон\r\n        this.use = function (name) {\r\n            if (!name || name == '')\r\n                throw new Error('Bad background name');\r\n\r\n            var\r\n                scenario = self.scenarios[self.scenarios.length - 1];\r\n\r\n            if (!scenario)\r\n                throw new Error(\"Can't set up background without scenario\");\r\n\r\n            scenario.background = name;\r\n            return self;\r\n        };\r\n    }\r\n\r\n    function feature(featureName, groupName) {\r\n        var f = new Feature(featureName, groupName);\r\n        featureRunner.enqueue(f, groupName);\r\n        return f;\r\n    }\r\n\r\n    function FeatureSteps(featurePattern) {\r\n        var self = this;\r\n        //TODO: зачем паттерн?\r\n        this.pattern = new RegExp(featurePattern);\r\n        this.beforeSteps = [];\r\n        this.afterSteps = [];\r\n        this.steps = [];\r\n        this.then = function (pattern, definition) {\r\n            return addStep(pattern, definition, true);\r\n        };\r\n        this.when = this.given = function () {\r\n            return addStep.call(self, arguments[0], arguments[1]);\r\n        };\r\n        this.before = function (definition) {\r\n            self.beforeSteps.push(definition);\r\n            return this;\r\n        };\r\n\r\n        this.after = function (definition) {\r\n            self.afterSteps.push(definition);\r\n            return this;\r\n        };\r\n\r\n        function addStep(pattern, definition, forceExpect) {\r\n            self.steps.push({\r\n                pattern: new RegExp('^' + pattern + '$'),\r\n                definition: definition,\r\n                name: pattern,\r\n                requireExpect: forceExpect\r\n            });\r\n            return self;\r\n        };\r\n    }\r\n\r\n    function makeStepsDescriber(name) {\r\n        return function (featurePattern) {\r\n            var featureSteps = new FeatureSteps(featurePattern);\r\n            var group = exports.stepsGroups[name] || (exports.stepsGroups[name] = []);\r\n\r\n            group.push(featureSteps);\r\n            return featureSteps;\r\n        };\r\n    }\r\n\r\n    exports.feature = feature;\r\n    exports.featureSteps = makeStepsDescriber('featureSteps');\r\n    exports.groupSteps = makeStepsDescriber('groupSteps');\r\n    exports.backgroundSteps = makeStepsDescriber('backgroundSteps');\r\n\r\n}(typeof window !== 'undefined' ? window : module.exports));"],"sourceRoot":""}